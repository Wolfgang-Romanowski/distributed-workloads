# Snyk scan for training‑runtime Images (Full Image Scanning)
# push to main, nightly 03:00 UTC, fork PRs after label `safe-to-test`
# Fails on High/Critical CVEs in built images

name: Snyk Image Security Scan

on:
  push:
    branches: [ main ]
    paths:
      - 'images/runtime/training/*/Dockerfile'
      - 'images/runtime/training/*/Pipfile'
  pull_request_target:
    types: [ labeled, opened, synchronize ]
  schedule:
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      debug:
        description: 'Enable debug mode'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      target_dir:
        description: 'Specific directory to scan (leave empty for all)'
        required: false
        default: ''
        type: string
      scan_mode:
        description: 'Scanning mode'
        required: false
        default: 'image'
        type: choice
        options:
          - 'image'
          - 'dockerfile'

jobs:
  snyk-image-scan:
    name: Snyk Image Security Scan
    runs-on: ubuntu-latest
    if: >
      github.event_name != 'pull_request_target' || 
      github.event.label.name == 'safe-to-test' || 
      github.event.pull_request.head.repo.owner.login == github.repository_owner
    permissions:
      contents: read
      security-events: write
    strategy:
      matrix:
        image_config:
          - { tag: "py311-cuda121-torch241", dockerfile: "images/runtime/training/py311-cuda121-torch241/Dockerfile" }
          - { tag: "py311-cuda124-torch251", dockerfile: "images/runtime/training/py311-cuda124-torch251/Dockerfile" }
          - { tag: "py311-rocm62-torch241", dockerfile: "images/runtime/training/py311-rocm62-torch241/Dockerfile" }
          - { tag: "py311-rocm62-torch251", dockerfile: "images/runtime/training/py311-rocm62-torch251/Dockerfile" }
      fail-fast: false
    env:
      QUAY_REGISTRY: "quay.io/modh/training"
      MAX_RETRY_ATTEMPTS: 3
      DOCKER_TIMEOUT: 1800  # 30 minutes for large images
      SCAN_TIMEOUT: 3600    # 1 hour for comprehensive scanning
      IMAGE_TAG: ${{ matrix.image_config.tag }}
      DOCKERFILE_PATH: ${{ matrix.image_config.dockerfile }}
      SCAN_MODE: ${{ github.event.inputs.scan_mode || 'image' }}
      DEBUG_MODE: ${{ github.event.inputs.debug == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.ref || '' }}
          repository: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.head.repo.full_name || '' }}

      - name: Setup Snyk
        uses: snyk/actions/setup@master

      - name: Configure Snyk Authentication
        id: verify_token
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          if [ -z "$SNYK_TOKEN" ]; then
            echo "::error::SNYK_TOKEN secret is not configured"
            exit 1
          fi
          
          # Validate token format (Snyk tokens are typically UUIDs)
          if [[ ! "$SNYK_TOKEN" =~ ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ ]]; then
            echo "::warning::SNYK_TOKEN does not appear to be in expected UUID format"
          fi
          
          echo "Configuring Snyk authentication..."
          if snyk auth "$SNYK_TOKEN"; then
            echo "✅ Snyk auth command completed"
          else
            echo "::error::Snyk auth command failed"
            exit 1
          fi
          
          echo "Testing Snyk authentication..."
          if snyk auth test; then
            echo "✅ Snyk authentication test successful"
            
            # Get additional info for debugging
            echo "Getting Snyk configuration info..."
            snyk config get api || echo "Could not get API endpoint"
            snyk whoami || echo "Could not get user info"
            
          else
            echo "::error::Snyk authentication test failed"
            echo "Debugging information:"
            echo "- Token length: ${#SNYK_TOKEN}"
            echo "- Token starts with: ${SNYK_TOKEN:0:8}..."
            echo "- Snyk CLI version: $(snyk --version)"
            exit 1
          fi
          
          echo "version=$(snyk --version)" >> $GITHUB_OUTPUT
          echo "✅ Snyk CLI version: $(snyk --version)"

      - name: Check Target Directory Filter
        id: check_target
        run: |
          TARGET_DIR="${{ github.event.inputs.target_dir }}"
          CURRENT_TAG="${{ matrix.image_config.tag }}"
          
          if [ -n "$TARGET_DIR" ] && [ "$TARGET_DIR" != "$CURRENT_TAG" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "Skipping $CURRENT_TAG (target: $TARGET_DIR)"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "Processing $CURRENT_TAG"
          fi

      - name: Initialize Scan Environment
        if: steps.check_target.outputs.skip == 'false'
        id: init
        run: |
          set -euo pipefail
          
          # Initialize scan environment
          mkdir -p scan_results
          echo "START_TIME=$(date +%s)" >> $GITHUB_ENV
          echo "BUILT_IMAGE=${QUAY_REGISTRY}:${IMAGE_TAG}" >> $GITHUB_ENV
          
          # Create utility functions script
          cat > scan_results/utils.sh << 'EOF'
          log_with_timestamp() {
            echo "$(date -u '+%Y-%m-%d %H:%M:%S UTC') - $1"
          }
          
          cleanup_resources() {
            log_with_timestamp "Cleaning up resources..."
            if [ "${IMAGE_PULLED:-false}" = "true" ] && [ -n "${BUILT_IMAGE:-}" ]; then
              docker rmi "$BUILT_IMAGE" 2>/dev/null || true
              log_with_timestamp "Cleaned up pulled image: $BUILT_IMAGE"
            fi
            find scan_results -name "*.tmp" -delete 2>/dev/null || true
          }
          
          validate_image_reference() {
            local image="$1"
            if [[ ! "$image" =~ ^[a-zA-Z0-9][a-zA-Z0-9._/-]*:[a-zA-Z0-9._-]+$ ]]; then
              log_with_timestamp "ERROR: Invalid image reference format: $image"
              return 1
            fi
            return 0
          }
          
          check_disk_space() {
            local required_gb=6
            local available_kb=$(df /var/lib/docker 2>/dev/null | tail -1 | awk '{print $4}' || echo "0")
            local available_gb=$((available_kb / 1024 / 1024))
            
            if [ "$available_gb" -lt "$required_gb" ]; then
              log_with_timestamp "ERROR: Insufficient disk space. Required: ${required_gb}GB, Available: ${available_gb}GB"
              return 1
            fi
            
            log_with_timestamp "Disk space check passed: ${available_gb}GB available"
            return 0
          }
          
          retry_with_backoff() {
            local max_attempts="$1"
            local delay="$2"
            local command_description="$3"
            shift 3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              log_with_timestamp "Attempt $attempt of $max_attempts: $command_description"
              
              if "$@"; then
                log_with_timestamp "Success: $command_description"
                return 0
              fi
              
              if [ $attempt -lt $max_attempts ]; then
                local wait_time=$((delay * attempt))
                log_with_timestamp "Failed, retrying in ${wait_time} seconds..."
                sleep $wait_time
              fi
              
              attempt=$((attempt + 1))
            done
            
            log_with_timestamp "ERROR: All attempts failed for: $command_description"
            return 1
          }
          
          extract_base_image() {
            local dockerfile="$1"
            local base_image=$(grep -m 1 "^FROM" "$dockerfile" | awk '{print $2}' | sed 's/ AS .*//g')
            local original_image="$base_image"
            
            while IFS= read -r line; do
              if [[ "$line" =~ ^ARG[[:space:]]+([^=[:space:]]+)=(.+)$ ]]; then
                local var_name="${BASH_REMATCH[1]}"
                local var_value="${BASH_REMATCH[2]//[\"\']}"
                base_image="${base_image//\$\{$var_name\}/$var_value}"
                base_image="${base_image//\$var_name/$var_value}"
              fi
            done < "$dockerfile"
            
            if [[ "$base_image" =~ \$\{.*\} ]] || [[ "$base_image" =~ \$[A-Z_]+ ]]; then
              echo "$original_image"
            else
              echo "$base_image"
            fi
          }
          
          get_vuln_counts() {
            local json_file="$1"
            if [ ! -f "$json_file" ] || [ ! -s "$json_file" ] || ! jq -e . "$json_file" >/dev/null 2>&1; then
              echo "0|0|0|0|0"
              return
            fi
            
            local critical=$(jq '[.vulnerabilities[]? | select(.severity == "critical")] | length' "$json_file" 2>/dev/null || echo "0")
            local high=$(jq '[.vulnerabilities[]? | select(.severity == "high")] | length' "$json_file" 2>/dev/null || echo "0")
            local medium=$(jq '[.vulnerabilities[]? | select(.severity == "medium")] | length' "$json_file" 2>/dev/null || echo "0")
            local low=$(jq '[.vulnerabilities[]? | select(.severity == "low")] | length' "$json_file" 2>/dev/null || echo "0")
            local total=$(jq '.uniqueCount // 0' "$json_file" 2>/dev/null || echo "0")
            
            echo "$critical|$high|$medium|$low|$total"
          }
          EOF
          
          chmod +x scan_results/utils.sh
          source scan_results/utils.sh
          
          # Set up cleanup trap
          trap cleanup_resources EXIT
          
          log_with_timestamp "Scan environment initialized for $IMAGE_TAG"

      - name: Validate Environment
        if: steps.check_target.outputs.skip == 'false'
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          source scan_results/utils.sh
          
          log_with_timestamp "Starting security scan for $IMAGE_TAG"
          log_with_timestamp "Configuration validation..."
          
          if [ ! -f "$DOCKERFILE_PATH" ]; then
            echo "scan_error=Dockerfile not found: $DOCKERFILE_PATH" >> $GITHUB_ENV
            log_with_timestamp "ERROR: Dockerfile not found: $DOCKERFILE_PATH"
            exit 1
          fi
          
          if ! validate_image_reference "$BUILT_IMAGE"; then
            echo "scan_error=Invalid image reference: $BUILT_IMAGE" >> $GITHUB_ENV
            exit 1
          fi
          
          if [ "$SCAN_MODE" = "image" ] && ! check_disk_space; then
            echo "scan_error=Insufficient disk space for image scanning" >> $GITHUB_ENV
            exit 1
          fi
          
          # Verify Snyk is still authenticated (auth should persist from previous step)
          log_with_timestamp "Verifying Snyk authentication..."
          if snyk auth test >/dev/null 2>&1; then
            log_with_timestamp "✅ Snyk authentication verified"
          else
            echo "scan_error=Snyk authentication verification failed" >> $GITHUB_ENV
            log_with_timestamp "ERROR: Snyk authentication verification failed"
            log_with_timestamp "Attempting to re-authenticate..."
            
            if [ -n "$SNYK_TOKEN" ] && snyk auth "$SNYK_TOKEN" >/dev/null 2>&1; then
              log_with_timestamp "✅ Snyk re-authentication successful"
            else
              log_with_timestamp "ERROR: Snyk re-authentication failed"
              exit 1
            fi
          fi
          
          log_with_timestamp "All validations passed"

      - name: Extract Base Image Information
        if: steps.check_target.outputs.skip == 'false'
        run: |
          source scan_results/utils.sh
          
          BASE_IMAGE=$(extract_base_image "$DOCKERFILE_PATH")
          echo "BASE_IMAGE=$BASE_IMAGE" >> $GITHUB_ENV
          echo "BASE_SCAN_KEY=${BASE_IMAGE//[:\/]/_}" >> $GITHUB_ENV
          
          log_with_timestamp "Configuration:"
          log_with_timestamp "  Image Tag: $IMAGE_TAG"
          log_with_timestamp "  Built Image: $BUILT_IMAGE"
          log_with_timestamp "  Base Image: $BASE_IMAGE"
          log_with_timestamp "  Dockerfile: $DOCKERFILE_PATH"
          log_with_timestamp "  Scan Mode: $SCAN_MODE"

      - name: Pull Image if Required
        if: steps.check_target.outputs.skip == 'false' && env.SCAN_MODE == 'image'
        run: |
          source scan_results/utils.sh
          
          log_with_timestamp "IMAGE MODE: Scanning complete built image"
          
          # Check if image exists remotely
          log_with_timestamp "Checking image availability: $BUILT_IMAGE"
          if retry_with_backoff 3 5 "check image existence" \
             docker manifest inspect "$BUILT_IMAGE" >/dev/null 2>&1; then
            log_with_timestamp "Image manifest verified"
            
            # Configure Docker for large image pulls
            export DOCKER_CLI_EXPERIMENTAL=enabled
            
            pull_image() {
              timeout $DOCKER_TIMEOUT docker pull "$BUILT_IMAGE" 2>&1 | \
              while read line; do
                if [[ "$line" =~ (Downloading|Extracting|Pull complete|Status) ]]; then
                  log_with_timestamp "Docker: $line"
                fi
              done
              return ${PIPESTATUS[0]}
            }
            
            log_with_timestamp "Pulling built image: $BUILT_IMAGE (this may take several minutes for large images)"
            if retry_with_backoff $MAX_RETRY_ATTEMPTS 30 "pull large image" pull_image; then
              echo "IMAGE_PULLED=true" >> $GITHUB_ENV
              log_with_timestamp "Successfully pulled $BUILT_IMAGE"
              
              if docker inspect "$BUILT_IMAGE" >/dev/null 2>&1; then
                log_with_timestamp "Image integrity verified"
              else
                log_with_timestamp "Image integrity check failed, but proceeding"
              fi
            else
              log_with_timestamp "Failed to pull $BUILT_IMAGE after $MAX_RETRY_ATTEMPTS attempts"
              log_with_timestamp "Attempting direct scan without local pull..."
            fi
          else
            echo "scan_error=Image not found or inaccessible: $BUILT_IMAGE" >> $GITHUB_ENV
            log_with_timestamp "ERROR: Image not found or inaccessible: $BUILT_IMAGE"
            exit 1
          fi

      - name: Scan Base Image
        if: steps.check_target.outputs.skip == 'false'
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          source scan_results/utils.sh
          
          BASE_SCAN_JSON="scan_results/base_${BASE_SCAN_KEY}.json"
          
          log_with_timestamp "Scanning base image for comparison: $BASE_IMAGE"
          
          scan_base_image() {
            timeout $SCAN_TIMEOUT snyk container test "$BASE_IMAGE" \
              --json \
              --severity-threshold=low \
              > "$BASE_SCAN_JSON" 2>/dev/null
          }
          
          set +e
          if retry_with_backoff 2 15 "base image scan" scan_base_image; then
            BASE_EXIT_CODE=0
          else
            BASE_EXIT_CODE=1
          fi
          set -e
          
          if [ -f "$BASE_SCAN_JSON" ] && [ -s "$BASE_SCAN_JSON" ] && jq -e . "$BASE_SCAN_JSON" >/dev/null 2>&1; then
            echo "BASE_SCAN_SUCCESSFUL=true" >> $GITHUB_ENV
            log_with_timestamp "Base image scan completed"
          else
            echo "BASE_SCAN_SUCCESSFUL=false" >> $GITHUB_ENV
            log_with_timestamp "Base image scan failed or returned invalid data"
            echo '{"vulnerabilities":[],"uniqueCount":0,"error":"base_scan_failed","timestamp":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' > "$BASE_SCAN_JSON"
          fi
          
          IFS='|' read -r base_critical base_high base_medium base_low base_total <<< "$(get_vuln_counts "$BASE_SCAN_JSON")"
          echo "BASE_CRITICAL=$base_critical" >> $GITHUB_ENV
          echo "BASE_HIGH=$base_high" >> $GITHUB_ENV
          echo "BASE_MEDIUM=$base_medium" >> $GITHUB_ENV
          echo "BASE_LOW=$base_low" >> $GITHUB_ENV
          echo "BASE_TOTAL=$base_total" >> $GITHUB_ENV

      - name: Scan Target Image
        if: steps.check_target.outputs.skip == 'false'
        id: target_scan
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          source scan_results/utils.sh
          
          FULL_SCAN_JSON="scan_results/${IMAGE_TAG}_full_scan.json"
          
          if [ "$SCAN_MODE" = "dockerfile" ]; then
            SCAN_TARGET="$BASE_IMAGE"
            log_with_timestamp "LEGACY MODE: Scanning base image only"
          else
            SCAN_TARGET="$BUILT_IMAGE"
          fi
          
          log_with_timestamp "Scanning target: $SCAN_TARGET"
          
          scan_target_image() {
            local temp_output="$FULL_SCAN_JSON.tmp"
            
            if [ "$SCAN_MODE" = "image" ]; then
              timeout $SCAN_TIMEOUT snyk container test "$SCAN_TARGET" \
                --file="$DOCKERFILE_PATH" \
                --json \
                --severity-threshold=low \
                --exclude-base-image-vulns=false \
                > "$temp_output" 2>/dev/null
            else
              timeout $SCAN_TIMEOUT snyk container test "$SCAN_TARGET" \
                --file="$DOCKERFILE_PATH" \
                --json \
                --severity-threshold=low \
                > "$temp_output" 2>/dev/null
            fi
            
            if [ -f "$temp_output" ] && [ -s "$temp_output" ] && jq -e . "$temp_output" >/dev/null 2>&1; then
              mv "$temp_output" "$FULL_SCAN_JSON"
              return 0
            else
              rm -f "$temp_output"
              return 1
            fi
          }
          
          set +e
          SCAN_EXIT_CODE=0
          
          if retry_with_backoff $MAX_RETRY_ATTEMPTS 30 "target image scan" scan_target_image; then
            echo "SCAN_SUCCESSFUL=true" >> $GITHUB_ENV
            log_with_timestamp "Target scan completed successfully"
          else
            SCAN_EXIT_CODE=1
            
            # Emergency retry for large images
            if [ "$SCAN_MODE" = "image" ] && [ "${IMAGE_PULLED:-false}" = "false" ]; then
              log_with_timestamp "Large image scan failed without local pull, attempting emergency pull..."
              
              if retry_with_backoff 1 60 "emergency image pull" docker pull "$BUILT_IMAGE" >/dev/null 2>&1; then
                echo "IMAGE_PULLED=true" >> $GITHUB_ENV
                if retry_with_backoff 1 60 "post-pull scan" scan_target_image; then
                  echo "SCAN_SUCCESSFUL=true" >> $GITHUB_ENV
                  SCAN_EXIT_CODE=0
                  log_with_timestamp "Target scan succeeded after emergency pull"
                fi
              fi
            fi
            
            if [ "${SCAN_SUCCESSFUL:-false}" = "false" ]; then
              SCAN_ERROR="Scan failed or returned invalid data for $SCAN_TARGET after $MAX_RETRY_ATTEMPTS attempts"
              echo "scan_error=$SCAN_ERROR" >> $GITHUB_ENV
              log_with_timestamp "ERROR: $SCAN_ERROR"
              echo '{"vulnerabilities":[],"uniqueCount":0,"error":"target_scan_failed","target":"'$SCAN_TARGET'","timestamp":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'","attempts":'$MAX_RETRY_ATTEMPTS'}' > "$FULL_SCAN_JSON"
            fi
          fi
          set -e

      - name: Calculate Vulnerabilities
        if: steps.check_target.outputs.skip == 'false'
        id: calculate
        run: |
          source scan_results/utils.sh
          
          FULL_SCAN_JSON="scan_results/${IMAGE_TAG}_full_scan.json"
          BASE_SCAN_JSON="scan_results/base_${BASE_SCAN_KEY}.json"
          
          # Calculate vulnerability counts
          IFS='|' read -r target_critical target_high target_medium target_low target_total <<< "$(get_vuln_counts "$FULL_SCAN_JSON")"
          
          # Calculate new vulnerabilities (those not in base image)
          if [ -f "$BASE_SCAN_JSON" ] && [ -f "$FULL_SCAN_JSON" ] && [ "${BASE_SCAN_SUCCESSFUL:-false}" = "true" ] && [ "${SCAN_SUCCESSFUL:-false}" = "true" ]; then
            BASE_VULN_SIGS=$(jq -r '[.vulnerabilities[]? | "\(.id // "unknown"):\(.packageName // "unknown"):\(.version // "unknown"):\(.severity // "unknown")"] | join(",")' "$BASE_SCAN_JSON" 2>/dev/null || echo "")
            
            if [ -z "$BASE_VULN_SIGS" ]; then
              NEW_CRITICAL=$target_critical
              NEW_HIGH=$target_high
              NEW_MEDIUM=$target_medium
              NEW_LOW=$target_low
            else
              NEW_CRITICAL=$(jq -r --arg base_sigs "$BASE_VULN_SIGS" '[.vulnerabilities[]? | select(.severity == "critical")] | map(select(("\(.id // "unknown"):\(.packageName // "unknown"):\(.version // "unknown"):\(.severity // "unknown")") as $sig | ($base_sigs | split(",") | index($sig) | not))) | length' "$FULL_SCAN_JSON" 2>/dev/null || echo "0")
              NEW_HIGH=$(jq -r --arg base_sigs "$BASE_VULN_SIGS" '[.vulnerabilities[]? | select(.severity == "high")] | map(select(("\(.id // "unknown"):\(.packageName // "unknown"):\(.version // "unknown"):\(.severity // "unknown")") as $sig | ($base_sigs | split(",") | index($sig) | not))) | length' "$FULL_SCAN_JSON" 2>/dev/null || echo "0")
              NEW_MEDIUM=$(jq -r --arg base_sigs "$BASE_VULN_SIGS" '[.vulnerabilities[]? | select(.severity == "medium")] | map(select(("\(.id // "unknown"):\(.packageName // "unknown"):\(.version // "unknown"):\(.severity // "unknown")") as $sig | ($base_sigs | split(",") | index($sig) | not))) | length' "$FULL_SCAN_JSON" 2>/dev/null || echo "0")
              NEW_LOW=$(jq -r --arg base_sigs "$BASE_VULN_SIGS" '[.vulnerabilities[]? | select(.severity == "low")] | map(select(("\(.id // "unknown"):\(.packageName // "unknown"):\(.severity // "unknown")") as $sig | ($base_sigs | split(",") | index($sig) | not))) | length' "$FULL_SCAN_JSON" 2>/dev/null || echo "0")
            fi
            
            NEW_TOTAL=$((NEW_CRITICAL + NEW_HIGH + NEW_MEDIUM + NEW_LOW))
          else
            NEW_CRITICAL=$target_critical
            NEW_HIGH=$target_high
            NEW_MEDIUM=$target_medium
            NEW_LOW=$target_low
            NEW_TOTAL=$target_total
          fi
          
          # Set outputs
          echo "target_critical=$target_critical" >> $GITHUB_OUTPUT
          echo "target_high=$target_high" >> $GITHUB_OUTPUT
          echo "target_medium=$target_medium" >> $GITHUB_OUTPUT
          echo "target_low=$target_low" >> $GITHUB_OUTPUT
          echo "target_total=$target_total" >> $GITHUB_OUTPUT
          echo "new_critical=$NEW_CRITICAL" >> $GITHUB_OUTPUT
          echo "new_high=$NEW_HIGH" >> $GITHUB_OUTPUT
          echo "new_medium=$NEW_MEDIUM" >> $GITHUB_OUTPUT
          echo "new_low=$NEW_LOW" >> $GITHUB_OUTPUT
          echo "new_total=$NEW_TOTAL" >> $GITHUB_OUTPUT

      - name: Determine Scan Status
        if: steps.check_target.outputs.skip == 'false'
        id: status
        run: |
          source scan_results/utils.sh
          
          NEW_CRITICAL=${{ steps.calculate.outputs.new_critical }}
          NEW_HIGH=${{ steps.calculate.outputs.new_high }}
          NEW_TOTAL=${{ steps.calculate.outputs.new_total }}
          
          # Calculate scan duration
          END_TIME=$(date +%s)
          SCAN_DURATION=$((END_TIME - START_TIME))
          
          # Determine scan status and message
          if [ "${SCAN_SUCCESSFUL:-false}" = "false" ]; then
            SCAN_STATUS="ERROR"
            SCAN_MESSAGE="Scan failed: ${scan_error:-Unknown error}"
          elif [ $NEW_CRITICAL -gt 0 ] || [ $NEW_HIGH -gt 0 ]; then
            SCAN_STATUS="FAILED"
            if [ $NEW_CRITICAL -gt 0 ] && [ $NEW_HIGH -gt 0 ]; then
              SCAN_MESSAGE="Found $NEW_CRITICAL critical and $NEW_HIGH high severity vulnerabilities"
            elif [ $NEW_CRITICAL -gt 0 ]; then
              SCAN_MESSAGE="Found $NEW_CRITICAL critical severity $([ $NEW_CRITICAL -eq 1 ] && echo "vulnerability" || echo "vulnerabilities")"
            else
              SCAN_MESSAGE="Found $NEW_HIGH high severity $([ $NEW_HIGH -eq 1 ] && echo "vulnerability" || echo "vulnerabilities")"
            fi
          elif [ $NEW_TOTAL -gt 0 ]; then
            SCAN_STATUS="WARNING"
            SCAN_MESSAGE="Found $NEW_TOTAL medium/low severity $([ $NEW_TOTAL -eq 1 ] && echo "vulnerability" || echo "vulnerabilities")"
          else
            SCAN_STATUS="PASSED"
            SCAN_MESSAGE="No new vulnerabilities found"
          fi
          
          # Debug mode handling
          if [ "$DEBUG_MODE" = "true" ] && [ "${BASE_TOTAL:-0}" -gt 0 ]; then
            SCAN_STATUS="FAILED"
            SCAN_MESSAGE="$SCAN_MESSAGE (Debug Mode: Base image has ${BASE_TOTAL} vulnerabilities)"
          fi
          
          # Output results
          log_with_timestamp "Scan Results for $IMAGE_TAG:"
          log_with_timestamp "  Scan Status: $SCAN_STATUS"
          log_with_timestamp "  Message: $SCAN_MESSAGE"
          log_with_timestamp "  Scan Duration: ${SCAN_DURATION}s"
          
          # Set outputs
          echo "scan_status=$SCAN_STATUS" >> $GITHUB_OUTPUT
          echo "scan_message=$SCAN_MESSAGE" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "built_image=$BUILT_IMAGE" >> $GITHUB_OUTPUT
          echo "base_image=$BASE_IMAGE" >> $GITHUB_OUTPUT
          echo "scan_mode=$SCAN_MODE" >> $GITHUB_OUTPUT
          echo "image_pulled=${IMAGE_PULLED:-false}" >> $GITHUB_OUTPUT
          echo "scan_successful=${SCAN_SUCCESSFUL:-false}" >> $GITHUB_OUTPUT
          echo "base_scan_successful=${BASE_SCAN_SUCCESSFUL:-false}" >> $GITHUB_OUTPUT
          echo "scan_duration=$SCAN_DURATION" >> $GITHUB_OUTPUT

      - name: Create Monitoring Project
        if: steps.check_target.outputs.skip == 'false' && env.SCAN_SUCCESSFUL == 'true' && env.SCAN_MODE == 'image'
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          source scan_results/utils.sh
          
          log_with_timestamp "Creating Snyk monitor project for continuous surveillance..."
          
          monitor_project() {
            timeout 300 snyk container monitor "$BUILT_IMAGE" \
              --file="$DOCKERFILE_PATH" \
              --project-name="training-$IMAGE_TAG" \
              --org="${SNYK_ORG_ID:-}" \
              --project-tags="team=rhoai,component=training,image=$IMAGE_TAG,scan_mode=$SCAN_MODE" \
              >/dev/null 2>&1
          }
          
          if retry_with_backoff 2 10 "monitor project creation" monitor_project; then
            log_with_timestamp "Monitor project created successfully"
            echo "monitor_created=true" >> $GITHUB_OUTPUT
          else
            log_with_timestamp "Monitor project creation failed (non-blocking)"
            echo "monitor_created=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate Scan Metadata
        if: steps.check_target.outputs.skip == 'false'
        run: |
          source scan_results/utils.sh
          
          END_TIME=$(date +%s)
          SCAN_DURATION=$((END_TIME - START_TIME))
          
          # Enhanced scan metadata with Red Hat QA compliance fields
          cat > "scan_results/scan_metadata_${IMAGE_TAG}.json" << EOF
          {
            "schema_version": "1.0",
            "image_tag": "$IMAGE_TAG",
            "built_image": "$BUILT_IMAGE",
            "base_image": "$BASE_IMAGE",
            "dockerfile_path": "$DOCKERFILE_PATH",
            "scan_mode": "$SCAN_MODE",
            "scan_status": "${{ steps.status.outputs.scan_status }}",
            "scan_message": "${{ steps.status.outputs.scan_message }}",
            "image_pulled": "${IMAGE_PULLED:-false}",
            "scan_successful": "${SCAN_SUCCESSFUL:-false}",
            "base_scan_successful": "${BASE_SCAN_SUCCESSFUL:-false}",
            "performance": {
              "scan_duration_seconds": $SCAN_DURATION,
              "max_retry_attempts": $MAX_RETRY_ATTEMPTS,
              "docker_timeout": $DOCKER_TIMEOUT,
              "scan_timeout": $SCAN_TIMEOUT
            },
            "vulnerabilities": {
              "target": {
                "critical": ${{ steps.calculate.outputs.target_critical }},
                "high": ${{ steps.calculate.outputs.target_high }},
                "medium": ${{ steps.calculate.outputs.target_medium }},
                "low": ${{ steps.calculate.outputs.target_low }},
                "total": ${{ steps.calculate.outputs.target_total }}
              },
              "base": {
                "critical": ${BASE_CRITICAL:-0},
                "high": ${BASE_HIGH:-0},
                "medium": ${BASE_MEDIUM:-0},
                "low": ${BASE_LOW:-0},
                "total": ${BASE_TOTAL:-0}
              },
              "new": {
                "critical": ${{ steps.calculate.outputs.new_critical }},
                "high": ${{ steps.calculate.outputs.new_high }},
                "medium": ${{ steps.calculate.outputs.new_medium }},
                "low": ${{ steps.calculate.outputs.new_low }},
                "total": ${{ steps.calculate.outputs.new_total }}
              }
            },
            "compliance": {
              "red_hat_compliant": true,
              "security_scan_version": "2.0",
              "baseline_comparison": ${BASE_SCAN_SUCCESSFUL:-false}
            },
            "environment": {
              "github_run_id": "${{ github.run_id }}",
              "github_run_number": "${{ github.run_number }}",
              "github_repository": "${{ github.repository }}",
              "github_ref": "${{ github.ref }}",
              "runner_os": "${{ runner.os }}",
              "snyk_version": "${{ steps.verify_token.outputs.version }}"
            },
            "timestamps": {
              "scan_start": "$START_TIME",
              "scan_end": "$END_TIME",
              "scan_timestamp": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')",
              "scan_timestamp_iso": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            },
            "error_details": {
              "scan_error": "${scan_error:-}",
              "has_errors": $([ -n "${scan_error:-}" ] && echo "true" || echo "false")
            }
          }
          EOF
          
          log_with_timestamp "Scan metadata saved to scan_results/scan_metadata_${IMAGE_TAG}.json"

      - name: Generate Security Report
        if: steps.check_target.outputs.skip == 'false'
        run: |
          source scan_results/utils.sh
          
          # Create detailed markdown report
          REPORT_FILE="scan_results/security_report_${IMAGE_TAG}.md"
          
          cat > "$REPORT_FILE" << EOF
          # Security Scan Report
          
          ## Image Information
          
          | Field | Value |
          |:------|:------|
          | **Image Tag** | \`$IMAGE_TAG\` |
          | **Built Image** | \`$BUILT_IMAGE\` |
          | **Base Image** | \`$BASE_IMAGE\` |
          | **Scan Mode** | $SCAN_MODE |
          | **Scan Status** | ${{ steps.status.outputs.scan_status }} |
          | **Image Pulled** | ${IMAGE_PULLED:-false} |
          | **Scan Date** | $(date -u '+%Y-%m-%d %H:%M UTC') |
          | **Snyk Version** | ${{ steps.verify_token.outputs.version }} |
          | **GitHub Run** | [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |
          
          ## Vulnerability Summary
          
          | Severity | Target Image | Base Image | New/Introduced |
          |:---------|:-------------|:-----------|:---------------|
          | **Critical** | ${{ steps.calculate.outputs.target_critical }} | ${BASE_CRITICAL:-0} | ${{ steps.calculate.outputs.new_critical }} |
          | **High** | ${{ steps.calculate.outputs.target_high }} | ${BASE_HIGH:-0} | ${{ steps.calculate.outputs.new_high }} |
          | **Medium** | ${{ steps.calculate.outputs.target_medium }} | ${BASE_MEDIUM:-0} | ${{ steps.calculate.outputs.new_medium }} |
          | **Low** | ${{ steps.calculate.outputs.target_low }} | ${BASE_LOW:-0} | ${{ steps.calculate.outputs.new_low }} |
          | **Total** | ${{ steps.calculate.outputs.target_total }} | ${BASE_TOTAL:-0} | ${{ steps.calculate.outputs.new_total }} |
          
          ## Scan Results
          
          **Status:** ${{ steps.status.outputs.scan_status }}  
          **Message:** ${{ steps.status.outputs.scan_message }}
          
          EOF
          
          if [ "${{ steps.calculate.outputs.new_total }}" -gt 0 ]; then
            cat >> "$REPORT_FILE" << EOF
          
          ## Next Steps
          
          Review the detailed vulnerability information in the scan artifacts and consider updating affected packages.
          
          EOF
          else
            cat >> "$REPORT_FILE" << EOF
          
          ## Result
          
          No new vulnerabilities found beyond those inherited from the base image.
          
          EOF
          fi
          
          cat >> "$REPORT_FILE" << EOF
          
          ---
          _Report generated by Snyk ${{ steps.verify_token.outputs.version }} on $(date -u '+%Y-%m-%d %H:%M UTC')_
          EOF
          
          log_with_timestamp "Security report generated: $REPORT_FILE"

      - name: Upload Scan Results
        if: always() && steps.check_target.outputs.skip == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: snyk-scan-results-${{ matrix.image_config.tag }}-${{ github.run_number }}
          path: |
            scan_results/
          retention-days: 30

      - name: Evaluate Exit Status
        if: steps.check_target.outputs.skip == 'false'
        run: |
          source scan_results/utils.sh
          
          SCAN_STATUS="${{ steps.status.outputs.scan_status }}"
          
          if [ "$SCAN_STATUS" = "ERROR" ]; then
            log_with_timestamp "ERROR: Scan failed for $IMAGE_TAG: ${scan_error:-Unknown error}"
            echo "::error::Scan failed for $IMAGE_TAG: ${scan_error:-Unknown error}"
            exit 1
          elif [ "$SCAN_STATUS" = "FAILED" ]; then
            log_with_timestamp "SECURITY FAILURE: Critical or high severity vulnerabilities found in $IMAGE_TAG"
            echo "::error::Security check failed for $IMAGE_TAG: Critical or high severity vulnerabilities found"
            exit 1
          else
            log_with_timestamp "Security check passed for $IMAGE_TAG"
            exit 0
          fi

      - name: Slack Notification
        if: |
          always() && 
          steps.check_target.outputs.skip == 'false' &&
          github.event_name != 'pull_request' && 
          (steps.status.outputs.scan_status == 'FAILED' || 
           steps.status.outputs.scan_status == 'ERROR' ||
           github.event.inputs.debug == 'true' ||
           github.event_name == 'schedule')
        continue-on-error: true
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          fields: repo,workflow,ref
          custom_payload: |
            {
              "attachments": [
                {
                  "color": "${{ steps.status.outputs.scan_status == 'PASSED' && 'good' || (steps.status.outputs.scan_status == 'WARNING' && 'warning' || 'danger') }}",
                  "title": "Snyk Image Security Scan - ${{ steps.status.outputs.scan_status }}${{ github.event_name == 'schedule' && ' (Nightly)' || '' }}",
                  "text": "${{ steps.status.outputs.scan_message }}",
                  "fields": [
                    {
                      "title": "Image",
                      "value": "`${{ steps.status.outputs.image_tag }}`",
                      "short": true
                    },
                    {
                      "title": "Scan Mode",
                      "value": "${{ steps.status.outputs.scan_mode == 'image' && 'Full Image' || 'Dockerfile Only' }}",
                      "short": true
                    },
                    {
                      "title": "New Vulnerabilities",
                      "value": "Critical: ${{ steps.calculate.outputs.new_critical }} | High: ${{ steps.calculate.outputs.new_high }} | Medium: ${{ steps.calculate.outputs.new_medium }} | Low: ${{ steps.calculate.outputs.new_low }}",
                      "short": false
                    },
                    {
                      "title": "Total in Image",
                      "value": "${{ steps.calculate.outputs.target_total }} total vulnerabilities found",
                      "short": true
                    },
                    {
                      "title": "Build Status",
                      "value": "${{ (steps.calculate.outputs.new_critical != '0' || steps.calculate.outputs.new_high != '0') && '❌ BLOCKED' || '✅ ALLOWED' }}",
                      "short": true
                    },
                    {
                      "title": "Scan Performance",
                      "value": "Duration: ${{ steps.status.outputs.scan_duration }}s | Image Pulled: ${{ steps.status.outputs.image_pulled }}",
                      "short": false
                    },
                    {
                      "title": "Repository",
                      "value": "${{ github.repository }}",
                      "short": true
                    },
                    {
                      "title": "Triggered By",
                      "value": "${{ github.event_name == 'schedule' && 'Nightly Schedule' || (github.event_name == 'workflow_dispatch' && 'Manual Run' || (github.event_name == 'push' && 'Push to Main' || github.event_name)) }}",
                      "short": false
                    }
                  ],
                  "actions": [
                    {
                      "type": "button",
                      "text": "View Security Report",
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    },
                    {
                      "type": "button", 
                      "text": "Download Results",
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts"
                    }
                  ],
                  "footer": "Snyk Container Security | Image: ${{ steps.status.outputs.built_image }}",
                  "footer_icon": "https://res.cloudinary.com/snyk/image/upload/v1537345894/press-kit/brand/logo-black.png"
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Aggregate results from all matrix jobs
  aggregate-results:
    name: Aggregate Security Results
    runs-on: ubuntu-latest
    needs: snyk-image-scan
    if: always()
    steps:
      - name: Evaluate Overall Status
        id: aggregate
        run: |
          echo "overall_status=COMPLETED" >> $GITHUB_OUTPUT
          echo "Aggregation job completed - check individual matrix job results for details"

      - name: Summary Notification
        if: |
          always() && 
          github.event_name != 'pull_request' && 
          github.event_name == 'schedule'
        continue-on-error: true
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          fields: repo,workflow,ref
          custom_payload: |
            {
              "attachments": [
                {
                  "color": "good",
                  "title": "Training Images Security Scan Summary - ${{ steps.aggregate.outputs.overall_status }}",
                  "text": "Completed security scanning for all training images",
                  "fields": [
                    {
                      "title": "Repository",
                      "value": "${{ github.repository }}",
                      "short": true
                    },
                    {
                      "title": "Branch",
                      "value": "${{ github.ref_name }}",
                      "short": true
                    },
                    {
                      "title": "Workflow Run",
                      "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|Run #${{ github.run_number }}>",
                      "short": false
                    }
                  ],
                  "footer": "Check individual job results for detailed vulnerability information"
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
